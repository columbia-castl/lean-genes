diff --git a/Makefile b/Makefile
index 5480536..0498327 100644
--- a/Makefile
+++ b/Makefile
@@ -5,13 +5,13 @@ WRAP_MALLOC=-DUSE_MALLOC_WRAPPERS
 AR=			ar
 DFLAGS=		-DHAVE_PTHREAD $(WRAP_MALLOC)
 LOBJS=		utils.o kthread.o kstring.o ksw.o bwt.o bntseq.o bwa.o bwamem.o bwamem_pair.o bwamem_extra.o malloc_wrap.o \
-			QSufSort.o bwt_gen.o rope.o rle.o is.o bwtindex.o
+			QSufSort.o bwt_gen.o rope.o rle.o is.o bwtindex.o read_pmt.o ../tiny-AES-c/aes.o
 AOBJS=		bwashm.o bwase.o bwaseqio.o bwtgap.o bwtaln.o bamlite.o \
 			bwape.o kopen.o pemerge.o maxk.o \
 			bwtsw2_core.o bwtsw2_main.o bwtsw2_aux.o bwt_lite.o \
 			bwtsw2_chain.o fastmap.o bwtsw2_pair.o
 PROG=		bwa
-INCLUDES=	
+INCLUDES=	-I../tiny-AES-c	
 LIBS=		-lm -lz -lpthread
 SUBDIRS=	.
 
@@ -44,12 +44,13 @@ depend:
 # DO NOT DELETE THIS LINE -- make depend depends on it.
 
 QSufSort.o: QSufSort.h
+../tiny-AES-c/aes.o: ../tiny-AES-c/aes.h 
 bamlite.o: bamlite.h malloc_wrap.h
 bntseq.o: bntseq.h utils.h kseq.h malloc_wrap.h khash.h
 bwa.o: bntseq.h bwa.h bwt.h ksw.h utils.h kstring.h malloc_wrap.h kvec.h
 bwa.o: kseq.h
 bwamem.o: kstring.h malloc_wrap.h bwamem.h bwt.h bntseq.h bwa.h ksw.h kvec.h
-bwamem.o: ksort.h utils.h kbtree.h
+bwamem.o: ksort.h utils.h kbtree.h read_pmt.h ../tiny-AES-c/aes.h
 bwamem_extra.o: bwa.h bntseq.h bwt.h bwamem.h kstring.h malloc_wrap.h
 bwamem_pair.o: kstring.h malloc_wrap.h bwamem.h bwt.h bntseq.h bwa.h kvec.h
 bwamem_pair.o: utils.h ksw.h
@@ -74,7 +75,7 @@ bwtsw2_main.o: bwt.h bwtsw2.h bntseq.h bwt_lite.h utils.h bwa.h
 bwtsw2_pair.o: utils.h bwt.h bntseq.h bwtsw2.h bwt_lite.h kstring.h
 bwtsw2_pair.o: malloc_wrap.h ksw.h
 example.o: bwamem.h bwt.h bntseq.h bwa.h kseq.h malloc_wrap.h
-fastmap.o: bwa.h bntseq.h bwt.h bwamem.h kvec.h malloc_wrap.h utils.h kseq.h
+fastmap.o: bwa.h bntseq.h bwt.h bwamem.h kvec.h malloc_wrap.h utils.h kseq.h read_pmt.h
 is.o: malloc_wrap.h
 kopen.o: malloc_wrap.h
 kstring.o: kstring.h malloc_wrap.h
@@ -83,6 +84,7 @@ main.o: kstring.h malloc_wrap.h utils.h
 malloc_wrap.o: malloc_wrap.h
 maxk.o: bwa.h bntseq.h bwt.h bwamem.h kseq.h malloc_wrap.h
 pemerge.o: ksw.h kseq.h malloc_wrap.h kstring.h bwa.h bntseq.h bwt.h utils.h
+read_pmt.o: read_pmt.h
 rle.o: rle.h
 rope.o: rle.h rope.h
 utils.o: utils.h ksort.h malloc_wrap.h kseq.h
diff --git a/bwamem.c b/bwamem.c
index 03e2a05..7cf82c7 100644
--- a/bwamem.c
+++ b/bwamem.c
@@ -46,6 +46,8 @@
 #  include "malloc_wrap.h"
 #endif
 
+#define AES_BLOCK_SIZE 16
+
 /* Theory on probability and scoring *ungapped* alignment
  *
  * s'(a,b) = log[P(b|a)/P(b)] = log[4P(b|a)], assuming uniform base distribution
@@ -872,7 +874,19 @@ void mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq
 	kputw((p->flag&0xffff) | (p->flag&0x10000? 0x100 : 0), str); kputc('\t', str); // FLAG
 	if (p->rid >= 0) { // with coordinate
 		kputs(bns->anns[p->rid].name, str); kputc('\t', str); // RNAME
-		kputl(p->pos + 1, str); kputc('\t', str); // POS
+		if (opt->pmt == NULL) {
+			kputl(p->pos + 1, str); kputc('\t', str); // POS
+		}
+		else {
+			if (p->pos < opt->pmt->pmt_size) {	
+				kputl(opt->pmt->pmt_table[p->pos + 1] , str); kputc('\t', str); //PMT POS
+				//printf("Original pos: %ld, permuted pos: %d\n", p->pos, opt->pmt->pmt_table[p->pos]);
+			}
+			else {
+				fprintf(stderr, "BWA-meme error! Wrong PMT loaded.\n");
+				exit(1);
+			}
+		}
 		kputw(p->mapq, str); kputc('\t', str); // MAPQ
 		add_cigar(opt, p, str, which);
 	} else kputsn("*\t0\t0\t*", 7, str); // without coordinte
@@ -902,8 +916,62 @@ void mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq
 			if ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qb += p->cigar[0]>>4;
 			if ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qe -= p->cigar[p->n_cigar-1]>>4;
 		}
-		ks_resize(str, str->l + (qe - qb) + 1);
-		for (i = qb; i < qe; ++i) str->s[str->l++] = "ACGTN"[(int)s->seq[i]];
+
+		if (opt->pmt == NULL){
+			ks_resize(str, str->l + (qe - qb) + 1);
+			for (i = qb; i < qe; ++i) str->s[str->l++] = "ACGTN"[(int)s->seq[i]];
+		}
+		else {
+			//ADDING ECB ENCRYPTION OF READS.
+			struct AES_ctx ctx;
+			uint8_t key[16];
+
+			//ks_resize(str, str->l + (qe - qb) + 1  + (AES_BLOCK_SIZE - ((qe - qb) % AES_BLOCK_SIZE)));
+			ks_resize(str, str->l + 2);
+			kputc('*', str);
+			
+			//TODO start w 0 key for debugging, etc
+			for (int i = 0; i < 16; i++) {
+				key[i] = 0;
+			}
+
+			AES_init_ctx(&ctx, key);
+
+			int len_scanned = 0;
+			unsigned char data_buf[AES_BLOCK_SIZE];
+
+			int num_blocks = (qe-qb)/AES_BLOCK_SIZE;
+			if ((qe-qb) % AES_BLOCK_SIZE) num_blocks++;
+			
+			//To treat it like a string, add the null terminator	
+			//data_buf[AES_BLOCK_SIZE] = 0;
+
+			for (i = 0; i < num_blocks; i++) {
+				for (int j = 0; j < AES_BLOCK_SIZE; j++) {
+					if (len_scanned >= (qe-qb)){
+						data_buf[j] = '0';
+					}
+					else {
+						data_buf[j] = "ACGTN"[(int)s->seq[len_scanned]];
+					}
+					len_scanned++;
+				}
+				//printf("ECB PREENCRYPTED DATABUF VAL:%s\n", data_buf);
+				AES_ECB_encrypt(&ctx, data_buf);
+				//printf("ECB ENCRYPTED DATABUF VAL: %s\n", data_buf);
+				for (int k = 0; k < AES_BLOCK_SIZE; k++) {
+					//printf("%02X ", data_buf[k]);
+					//str->s[str->l++] = data_buf[k];
+				}
+				//printf("\n");
+				fwrite(data_buf, AES_BLOCK_SIZE, 1, opt->encrypt_out);
+
+				//AES_ECB_decrypt(&ctx, data_buf);
+				//printf("CONFIRM DECRYPT: %s\n", data_buf);
+			}
+			//printf("*****\n\n");
+		}
+	
 		kputc('\t', str);
 		if (s->qual) { // printf qual
 			ks_resize(str, str->l + (qe - qb) + 1);
@@ -916,9 +984,65 @@ void mem_aln2sam(const mem_opt_t *opt, const bntseq_t *bns, kstring_t *str, bseq
 			if ((p->cigar[0]&0xf) == 4 || (p->cigar[0]&0xf) == 3) qe -= p->cigar[0]>>4;
 			if ((p->cigar[p->n_cigar-1]&0xf) == 4 || (p->cigar[p->n_cigar-1]&0xf) == 3) qb += p->cigar[p->n_cigar-1]>>4;
 		}
-		ks_resize(str, str->l + (qe - qb) + 1);
-		for (i = qe-1; i >= qb; --i) str->s[str->l++] = "TGCAN"[(int)s->seq[i]];
+		
+	
+		if (opt->pmt == NULL) {	
+			ks_resize(str, str->l + (qe - qb) + 1);
+			for (i = qe-1; i >= qb; --i) str->s[str->l++] = "TGCAN"[(int)s->seq[i]];
+		}
+		else {
+			//ADDING ECB ENCRYPTION OF READS.
+			struct AES_ctx ctx;
+			uint8_t key[16];
+
+			//ks_resize(str, str->l + (qe - qb) + 1  + (AES_BLOCK_SIZE - ((qe - qb) % AES_BLOCK_SIZE)));
+			ks_resize(str, str->l + 2);
+			kputc('*', str);
+			
+			//TODO start w 0 key for debugging, etc
+			for (int i = 0; i < 16; i++) {
+				key[i] = 0;
+			}
+
+			AES_init_ctx(&ctx, key);
+
+			int len_scanned = 0;
+			unsigned char data_buf[AES_BLOCK_SIZE];
+
+			int num_blocks = (qe-qb)/AES_BLOCK_SIZE;
+			if ((qe-qb) % AES_BLOCK_SIZE) num_blocks++;
+			
+			//To treat it like a string, add the null terminator	
+			//data_buf[AES_BLOCK_SIZE] = 0;
+
+			for (i = 0; i < num_blocks; i++) {
+				for (int j = 0; j < AES_BLOCK_SIZE; j++) {
+					if (len_scanned >= (qe-qb)){
+						data_buf[j] = '0';
+					}
+					else {
+						data_buf[j] = "TGCAN"[(int)s->seq[(qe-1) - len_scanned]];
+					}
+					len_scanned++;
+				}
+				//printf("ECB PREENCRYPTED DATABUF VAL:%s\n", data_buf);
+				AES_ECB_encrypt(&ctx, data_buf);
+				//printf("ECB ENCRYPTED DATABUF VAL: %s\n", data_buf);
+				for (int k = 0; k < AES_BLOCK_SIZE; k++) {
+					//printf("%02X ", data_buf[k]);
+					//str->s[str->l++] = data_buf[k];
+				}
+				//printf("\n");
+				fwrite(data_buf, AES_BLOCK_SIZE, 1, opt->encrypt_out);
+
+				//AES_ECB_decrypt(&ctx, data_buf);
+				//printf("CONFIRM DECRYPT: %s\n", data_buf);
+			}
+			//printf("*****\n\n");
+		}
+	
 		kputc('\t', str);
+		
 		if (s->qual) { // printf qual
 			ks_resize(str, str->l + (qe - qb) + 1);
 			for (i = qe-1; i >= qb; --i) str->s[str->l++] = s->qual[i];
diff --git a/bwamem.h b/bwamem.h
index 0a0e3bb..fd09605 100644
--- a/bwamem.h
+++ b/bwamem.h
@@ -30,10 +30,15 @@
 #include "bwt.h"
 #include "bntseq.h"
 #include "bwa.h"
+#include "read_pmt.h"
+#include "aes.h"
 
 #define MEM_MAPQ_COEF 30.0
 #define MEM_MAPQ_MAX  60
 
+#define ENCRYPT_FILE "encrypted.bytes"
+#define MAX_BATCH_DIGITS 4
+
 struct __smem_i;
 typedef struct __smem_i smem_i;
 
@@ -81,6 +86,10 @@ typedef struct {
 	int max_matesw;         // perform maximally max_matesw rounds of mate-SW for each end
 	int max_XA_hits, max_XA_hits_alt; // if there are max_hits or fewer, output them all
 	int8_t mat[25];         // scoring matrix; mat[0] == 0 if unset
+	
+	struct pmt_struct* pmt;
+	FILE* encrypt_out;
+	int batch_id;
 } mem_opt_t;
 
 typedef struct {
diff --git a/fastmap.c b/fastmap.c
index be7ba0e..421128b 100644
--- a/fastmap.c
+++ b/fastmap.c
@@ -156,7 +156,7 @@ int main_mem(int argc, char *argv[])
 
 	aux.opt = opt = mem_opt_init();
 	memset(&opt0, 0, sizeof(mem_opt_t));
-	while ((c = getopt(argc, argv, "51qpaMCSPVYjuk:c:v:s:r:t:R:A:B:O:E:U:w:L:d:T:Q:D:m:I:N:o:f:W:x:G:h:y:K:X:H:F:z:")) >= 0) {
+	while ((c = getopt(argc, argv, "51qpaMCSPVYjue:k:c:v:s:r:t:R:A:B:O:E:U:w:L:d:T:Q:D:m:I:N:o:f:W:x:G:h:y:K:X:H:F:z:")) >= 0) {
 		if (c == 'k') opt->min_seed_len = atoi(optarg), opt0.min_seed_len = 1;
 		else if (c == '1') no_mt_io = 1;
 		else if (c == 'x') mode = optarg;
@@ -193,6 +193,21 @@ int main_mem(int argc, char *argv[])
 		else if (c == 'K') fixed_chunk_size = atoi(optarg);
 		else if (c == 'X') opt->mask_level = atof(optarg);
 		else if (c == 'F') bwa_dbg = atoi(optarg);
+		else if (c == 'e') {
+			opt->pmt = read_pmt(DEFAULT);
+			opt->batch_id = atoi(optarg);
+
+			char* filename = malloc(strlen(ENCRYPT_FILE) + MAX_BATCH_DIGITS + 1);
+			strcpy(filename, ENCRYPT_FILE);
+			strcat(filename, "_");
+
+			char id_string[MAX_BATCH_DIGITS];
+			sprintf(id_string, "%d", opt->batch_id);
+			strcat(filename, id_string);
+
+			opt->encrypt_out = fopen(filename, "wb");
+			free(filename);
+		}
 		else if (c == 'h') {
 			opt0.max_XA_hits = opt0.max_XA_hits_alt = 1;
 			opt->max_XA_hits = opt->max_XA_hits_alt = strtol(optarg, &p, 10);
@@ -264,6 +279,10 @@ int main_mem(int argc, char *argv[])
 	}
 
 	if (opt->n_threads < 1) opt->n_threads = 1;
+
+	//printf("argc: %d\n", argc);
+	//printf("optind: %d\n", optind);
+
 	if (optind + 1 >= argc || optind + 3 < argc) {
 		fprintf(stderr, "\n");
 		fprintf(stderr, "Usage: bwa mem [options] <idxbase> <in1.fq> [in2.fq]\n\n");
@@ -394,6 +413,11 @@ int main_mem(int argc, char *argv[])
 	aux.actual_chunk_size = fixed_chunk_size > 0? fixed_chunk_size : opt->chunk_size * opt->n_threads;
 	kt_pipeline(no_mt_io? 1 : 2, process, &aux, 3);
 	free(hdr_line);
+	if (opt->pmt != NULL) {
+		fclose(opt->encrypt_out);
+		free(opt->pmt->pmt_table);
+		free(opt->pmt);
+	}
 	free(opt);
 	bwa_idx_destroy(aux.idx);
 	kseq_destroy(aux.ks);
